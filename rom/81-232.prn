# File 81-232.s
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Analysis of the Kaypro II ROM 
0000			; 
0000			; Based on 81-232.rom 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; NOTES: 
0000			; 
0000			;   The code if similar to the 81-149c ROM with the following 
0000			; differences: 
0000			;   - The welcome message says "Kaypro" instead of "Kaypro II" 
0000			;   - Support for double sided doble density disks (DSDD) 
0000			;   - The code goes 144 bytes beyong the 2KB limit and needs a 4KB 
0000			; ROM. All the reamining spce is filled with FF. 
0000			;   - The PIO-2A bit 6 is configured as output. 
0000			; 
0000			;   To support the DSDD disks, a new disk parameter block. This 
0000			; block is not copied to upper RAM as the SSSD and SSDD blocks were. 
0000			; Instead the upper RAM copy of SSDD is replaced by the disk 
0000			; parameter block for DSDD when needed. Also, the previously unused 
0000			; system bit 2 is used to select single side or double side mode. 
0000			; 
0000			;   On the ROM 81.149c, the current track of both drives is stored 
0000			; on two variables. Also, the density detected for the current disk 
0000			; on each drive is stored as an aditional 16th byte of the disk 
0000			; parameter header. On this ROM, there is a need to store as well if 
0000			; the disk is double sided. Current track, density and sides are now 
0000			; stored per drive in the variables disk_active_info_drive_a and 
0000			; disk_active_info_drive_b. It is copied back an forth to 
0000			; disk_active_info as A: or B: is selected.  
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; CONSTANTS 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; I/O Ports 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			io_00_serial_baud_rate:     EQU 0x00 
0000			io_04_serial_data:          EQU 0x04 
0000			io_05_keyboard_data:        EQU 0x05 
0000			io_06_serial_control:       EQU 0x06 
0000			io_07_keyboard_control:     EQU 0x07 
0000			io_08_parallel_data:        EQU 0x08 
0000			io_09_parallel_control:     EQU 0x09 
0000			io_0b_parallel_b_control:   EQU 0x0b 
0000			io_0c_keyboad_baud_rate:    EQU 0x0c 
0000			io_10_fdc_status:           EQU 0x10 ; as IN it is a get status 
0000			io_10_fdc_command:          EQU 0x10 ; as OUT it is a command 
0000			io_11_fdc_track:            EQU 0x11 
0000			io_12_fdc_sector:           EQU 0x12 
0000			io_13_fdc_data:             EQU 0x13 
0000			io_14_scroll_register:      EQU 0x14 
0000			io_1c_system_bits:          EQU 0x1c 
0000			io_1d_system_bits_control:  EQU 0x1d 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; System bits 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			system_bit_drive_a:                 EQU 0 
0000			system_bit_drive_b:                 EQU 1 
0000			system_bit_side_2:                  EQU 2 
0000			system_bit_centronicsReady:         EQU 3 
0000			system_bit_centronicsStrobe:        EQU 4 
0000			system_bit_double_density_neg:      EQU 5 
0000			system_bit_motors_neg:              EQU 6 
0000			system_bit_bank:                    EQU 7 
0000			 
0000			system_bit_drive_a_mask:            EQU 0x01 
0000			system_bit_drive_b_mask:            EQU 0x02 
0000			system_bit_side_2_mask:             EQU 0x04 
0000			system_bit_centronicsReady_mask:    EQU 0x08 
0000			system_bit_centronicsStrobe_mask:   EQU 0x10 
0000			system_bit_double_density_neg_mask: EQU 0x20 
0000			system_bit_motors_meg_mask:         EQU 0x40 
0000			system_bit_bank_mask:               EQU 0x80 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Console constants 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			address_vram:                    EQU 0x3000 
0000			console_lines:                   EQU 24 
0000			console_columns:                 EQU 80 
0000			console_line_length:             EQU 0x80 ; There are 80 cols, but 128 bytes reserved for each line 
0000			console_line_mask:               EQU 0x7f 
0000			 
0000			address_vram_end:                EQU address_vram + console_lines * console_line_length -1 ; 0x3bff 
0000			address_vram_start_of_last_line: EQU address_vram_end - console_line_length + 1            ; 0x3b80 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Disk constants 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			logical_sector_size:                EQU 128 ; See NOTES 
0000			double_density_sector_size:         EQU 1024 ; See NOTES 
0000			sectors_per_track_double_density:   EQU 40 ; See NOTES 
0000			tracks_per_side:                    EQU 10 ; See NOTES 
0000			disk_count:                         EQU 2 ; 0 is A: and 1 is B: 
0000			 
0000			fdc_command_restore:                EQU 0x00 
0000			fdc_command_read_address:           EQU 0xc4 
0000			fdc_command_seek:                   EQU 0x10 
0000			fdc_command_read_sector:            EQU 0x88 
0000			fdc_command_write_sector:           EQU 0xac 
0000			fdc_command_force_interrupt:        EQU 0xd0 
0000			 
0000			rw_mode_single_density: EQU 1 ; We read or write 128 bytes directly to/from DMA 
0000			rw_mode_double_density: EQU 4 ; We read or write the full 512 bytes buffer 
0000			 
0000			fdc_status_record_busy_bit:         EQU 0 
0000			fdc_status_record_not_found_bit:    EQU 4 
0000			fdc_status_read_error_bitmask:      EQU 0x9c ; Not ready, record not found, crc error or lost data 
0000			fdc_status_write_error_bitmask:     EQU 0xfc ; Not ready, write_protect, write fault, record not found, crc error or lost data 
0000			 
0000			; RET, used to set the NMI_ISR when the ROM is disabled 
0000			RET_opcode:	       EQU 0xC9 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; The first boot sector has the info about 
0000			; the rest of the boot sector loading 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			first_sector_load_address:     EQU 0xfa00 
0000			address_to_load_second_sector: EQU 0xfa02 
0000			address_to_exec_boot:          EQU 0xfa04 
0000			count_of_boot_sectors_needed:  EQU 0xfa06 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Disk related variables 
0000			; Sector address is given by the DTS (Drive, Track and Sector) 
0000			; For double density the sector is divided by 4 to account for 512 
0000			; bytes sector. 
0000			; See "Uninitialized RAM data areas" in Appendix G 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			 
0000			; DTS with the user requested data. Uses losgical sectors of 128 bytes 
0000			drive_selected:                 EQU 0xfc00 
0000			track_selected:                 EQU 0xfc01 ; 2 bytes 
0000			sector_selected:                EQU 0xfc03 
0000			 
0000			; DTS as understood by the floppy disk controller. Sectors are 512 bytes 
0000			drive_in_fdc:                   EQU 0xfc04 
0000			track_in_fdc:                   EQU 0xfc05 ; 2 bytes 
0000			sector_in_fdc:                  EQU 0xfc07 
0000			 
0000			dd_sector_selected:             EQU 0xfc08 ; the double density sector is sector_selected / 4 
0000			fdc_set_flag:                   EQU 0xfc09 ; 'hstact' 
0000			pending_write_flag:             EQU 0xfc0a ; 'hstwrt' 
0000			 
0000			pending_count:                  EQU 0xfc0b 
0000			drive_unallocated:              EQU 0xfc0c 
0000			track_unallocated:              EQU 0xfc0d ; 2 bytes 
0000			sector_unallocated:             EQU 0xfc0f 
0000			 
0000			rw_result:                      EQU 0xfc10 
0000			 
0000			read_needed_flag:               EQU 0xfc11 
0000			read_not_needed:                EQU 0 
0000			read_needed:                    EQU 1 
0000			 
0000			; See CP/M 2.2 System alteration guide appendix G 
0000			operation_type:                 EQU 0xfc12 ; 'readop' in appendix G 
0000			operation_type_write:           EQU 0 
0000			operation_type_read:            EQU 1 
0000			 
0000			; See CP/M 2.2 System alteration guide, section 12 and appendix G 
0000			rw_type:                        EQU 0xfc13 ; 'wrtype' in appendix G 
0000			rw_type_normal_write:              EQU 0 ; write to allocated 
0000			rw_type_directory_write:           EQU 1 
0000			rw_type_read_or_unallocated_write: EQU 2 ; write to unallocated 
0000			disk_DMA_address:               EQU 0xfc14 ; 2 bytes 
0000			 
0000			; There are 4 sector buffers. To select the buffer we get the sector modulo 4 
0000			sector_buffer_base:             EQU 0xfc16 
0000			sector_buffer_0:                EQU 0xfc16 
0000			sector_buffer_1:                EQU 0xfc16 + logical_sector_size 
0000			sector_buffer_2:                EQU 0xfc16 + logical_sector_size * 2 
0000			sector_buffer_3:                EQU 0xfc16 + logical_sector_size * 3 
0000			 
0000			disk_active_drive:              EQU 0xfe16 
0000			; There are three bytes with the disk info: track, density, sides support 
0000			disk_active_info:               EQU 0xfe17 
0000			disk_active_info_undefined:     EQU 0xff 
0000			disk_active_track:              EQU disk_active_info + 0 
0000			disk_density:                   EQU disk_active_info + 1 
0000			disk_density_double:            EQU 0x00 ; FM encoding 
0000			disk_density_single:            EQU 0x20 ; MFM encoding 
0000			disk_active_has_sides:          EQU disk_active_info + 2 
0000			disk_active_has_sides_no:       EQU 0x00 
0000			disk_active_has_sides_yes:      EQU 0xff 
0000			 
0000			; Copy of the disk info for the drive A: (3 bytes) 
0000			disk_active_info_drive_a:       EQU 0xfe1a ; 3 bytes copy of 0xfe17, 8 and 9 
0000			; Copy of the disk info for the drive B: (3 bytes) 
0000			disk_active_info_drive_b:       EQU 0xfe1d ; 3 bytes copy of 0xfe17, 8 and 9 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Console related variables 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			console_esc_mode:               EQU 0xfe74 
0000			console_esc_mode_clear:         EQU 0 ; No ESC pending 
0000			console_esc_mode_enabled:       EQU 1 ; Next char is the ESC command 
0000			console_esc_mode_arg_1:         EQU 2 ; Next char is the first arg of the = command 
0000			console_esc_mode_arg_2:         EQU 3 ; Next char is the second arg of the = command 
0000			console_esc_equal_first_arg:    EQU 0xfe75 ; First arg of the esc= command 
0000			console_cursor_position:        EQU 0xfe76 ; 2 bytes 
0000			 
0000			; On greek mode, the char is converted to a control char that is printed as a greek letter 
0000			console_alphabet_mask:          EQU 0xfe78 
0000			console_alphabet_ascii_mask:    EQU 0x7f 
0000			console_alphabet_greek_mask:    EQU 0x1f 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Entry points of code relocated to upper RAM 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			disk_params_destination:        EQU 0xfe79 
0000			disk_parameter_header_0:        EQU 0xfe79 
0000			disk_parameter_header_1:        EQU 0xfe8a 
0000			disk_parameter_block_single_density:    EQU 0xfe9b 
0000			disk_parameter_block_double_density:    EQU 0xfeaa 
0000			disk_sector_translation_table:  EQU 0xfeb9 
0000			disk_parameter_block_size:      EQU 15 
0000			disk_read_address_buffer:       EQU 0xfecb 
0000			disk_read_address_sector:       EQU 0xfecd 
0000			disk_read_address_buffer_size:  EQU 6 
0000			 
0000			relocation_destination:         EQU 0xfed1 
0000			relocation_offset:              EQU 0xfed1 - 0x03b   ; relocation_destination - block_to_relocate 
0000			read_single_density_relocated:  EQU 0xfee0           ; reloc_single_density + relocation_offset 
0000			move_RAM_relocated:             EQU 0xfed1           ; reloc_move_RAM + relocation_offset 
0000			read_to_buffer_relocated:       EQU 0xfee7           ; reloc_read_to_buffer + relocation_offset 
0000			write_from_buffer_relocated:    EQU 0xfef8           ; reloc_write_from_buffer + relocation_offset 
0000			write_single_density_relocated: EQU 0xfef1           ; reloc_write_single_density + relocation_offset 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; Other addresses 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			CSV_0:      EQU 0xfe20 ; Scrathpad for change disk check, drive 0 
0000			ALV_0:      EQU 0xfe30 ; Scrathpad for BDOS disk allocation, drive 0 
0000			CSV_1:      EQU 0xfe4a ; Scrathpad for change disk check, drive 1 
0000			ALV_1:      EQU 0xfe5a ; Scrathpad for BDOS disk allocation, drive 1 
0000			DIRBUF:     EQU 0xff6d ; Address of a 128 byte scratchpad for BDOS dir ops 
0000			 
0000			 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			; BIOS ENTRY POINTS 
0000			; 
0000			; Description of the entry points adapted from the KayPLUS manual. 
0000			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0000			 
0000			ORG	0h 
0000			    ; COLD: Resets entire computer system and is ALMOST like 
0000			    ; pressing the RESET button. 
0000			    ; Corresponds to CP/M BIOS function BOOT 
0000 c3 4b 00		    JP EP_COLD 
0003			 
0003			    ; INITDSK: Resets the disk input/output buffer status to empty. 
0003			    ; Any pending write is lost. Useful to perform a "soft" disk reset. 
0003 c3 95 01		    JP EP_INITDSK 
0006			 
0006			    ; INITVID: Resets the video system. Video hardware is configured 
0006			    ; and screen is cleared 
0006 c3 98 06		    JP EP_INITVID 
0009			 
0009			    ; INITDEV: Initializes tall I/O ports. 
0009 c3 fb 05		    JP EP_INITDEV 
000c			 
000c			    ; HOME: Sets track number to 0 
000c			    ; Corresponds to CP/M BIOS function HOME 
000c c3 e7 01		    JP EP_HOME 
000f			 
000f			    ; SELDSK: Selects logical drive in register C (value of 0 through 1), 
000f			    ; corresponding to drives A or B). SELDSK determines what type of 
000f			    ; disk (density) is present in the drive. 
000f			    ; Corresponds to CP/M BIOS function SELDSK 
000f c3 c3 01		    JP EP_SELDSK 
0012			 
0012			    ; SETTRK: Sets the track number to the value in register BC. No seek 
0012			    ; is actually performed until a disk read/write occurs. 
0012			    ; Corresponds to CP/M BIOS function SETTRK 
0012 c3 db 01		    JP EP_SETTRK 
0015			 
0015			    ; SETSEC: Sets the logical sector number to the value in register C. 
0015			    ; Corresponds to CP/M BIOS function SETSEC 
0015 c3 ca 01		    JP EP_SETSEC 
0018			 
0018			    ; SETDMA: Specifies the DMA address where disk read/write occurs in 
0018			    ; memory. The address in register pair BC is used until another DMA 
0018			    ; address is specified. 
0018			    ; Corresponds to CP/M BIOS function SETDMA 
0018 c3 d6 01		    JP EP_SETDMA 
001b			 
001b			    ; READ: Reads the previously-specified logical sector from specified 
001b			    ; track and disk into memory at the DMA address. Note that on 
001b			    ; double-density disks and the hard drive, one physical sector may be 
001b			    ; composed of up to eight logical sectors, so a physical disk read 
001b			    ; may not actually occur. Returns disk status in A with zero 
001b			    ; indicating no error occurred and a non-zero value indicating an 
001b			    ; error. 
001b			    ; Corresponds to CP/M BIOS function READ 
001b c3 fb 01		    JP EP_READ 
001e			 
001e			    ; WRITE: Same as above, but writes from memory to disk. 
001e			    ; Corresponds to CP/M BIOS function WRITE 
001e c3 16 02		    JP EP_WRITE 
0021			 
0021			    ; SECTRAN: Translates logical sector number to physical sector number 
0021			    ; Corresponds to CP/M BIOS function SECTRAN 
0021 c3 79 04		    JP EP_SECTRAN 
0024			 
0024			    ; DISKON: Turns on the disk drive. 
0024 c3 a2 04		    JP EP_DISKON 
0027			 
0027			    ; DISKOFF: Turns off the disk drive. 
0027 c3 b1 04		    JP EP_DISKOFF 
002a			 
002a			    ; KBDSTAT: Simply returns status of keyboard queue. Returns 0FFH if 
002a			    ; a key is available, or 00H otherwise. 
002a			    ; Corresponds to CP/M BIOS function CONST 
002a c3 08 06		    JP EP_KBDSTAT 
002d			 
002d			    ; KBDIN: Gets character from keyboard buffer or waits for one, if 
002d			    ; none ready.  
002d			    ; Corresponds to CP/M BIOS function CONIN 
002d c3 10 06		    JP EP_KBDIN 
0030			 
0030			    ; KBDOUT: Sends the character in register A to the keyboard port. 
0030 c3 1b 06		    JP EP_KBDOUT 
0033			 
0033			    ; SIOSTI: Returns status of SIO-B input port. Returns 00H if no 
0033			    ; character is ready, or 0FFH otherwise. 
0033 c3 5f 06		    JP EP_SIOSTI 
0036			 
0036			    ; SIOIN: Gets character from SIO-B input port, or waits for one if 
0036			    ; none is ready. 
0036 c3 65 06		    JP EP_SIOIN 
0039			 
0039			    ; SIOOUT: Sends character to SIO-B output port. 
0039 c3 6d 06		    JP EP_SIOOUT 
003c			 
003c			    ; LISTST: Returns the list status of the Centronics port: 00H is 
003c			    ; returned if the printer is busy, 0FFH if ready. 
003c c3 7d 06		    JP EP_LISTST 
003f			 
003f			    ; LIST: Sends the character in register C to the Centronics port. 
003f c3 85 06		    JP EP_LIST 
0042			 
0042			    ; SERSTO: Returns status of SIO-B output port. Returns 0FFH if SIO-B 
0042			    ; is ready to accept a character for output, and 00H otherwise. 
0042 c3 77 06		    JP EP_SERSTO 
0045			 
0045			    ; VIDOUT: Sends character in register C to video screen. All characters 
0045			    ; 20H (blank) to 7FH are directly displayed and screen scroll is done, 
0045			    ; if required. Characters below 20H are defined as control characters. 
0045 c3 b1 06		    JP EP_VIDOUT 
0048			 
0048			    ; DELAY: This entry point performs a "B times 10 mSec" delay. The 
0048			    ; 10 mSec delay is preset for 4 MHz. "B" is the value in the B-register 
0048			    ; and ranges from 1 to 256 decimal (0 is treated as 256). 
0048 c3 b8 04		    JP EP_DELAY 
004b			 
004b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
004b			; INITIALIZATION AND BOOT FROM DISK 
004b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
004b			 
004b			EP_COLD: 
004b f3			    DI 
004c 31 ff ff		    LD SP, 0xffff 
004f 06 0a		    LD B, 0xa ; 100ms delay 
0051 cd b8 04		    CALL EP_DELAY 
0054			    ; Init the system, io ports, screen and memory 
0054 cd fb 05		    CALL EP_INITDEV 
0057 cd 98 06		    CALL EP_INITVID 
005a cd 95 01		    CALL EP_INITDSK 
005d			    ; Avoid the NMI entry point at 0x0066 
005d 18 08		    JR EP_COLD_continue                         
005f 3d c3 3b 2b af 32 13	    DB 0x3D, 0xC3, 0x3B, 0x2B, 0xAF, 0x32, 0x13 
0066			 
0066			nmi_isr: 
0066			    ; Just return from the interrupts generated 
0066			    ; by the floppy controller 
0066 c9			    RET 
0067			 
0067			EP_COLD_continue: 
0067			    ; Show the wellcome message 
0067 cd 85 08		    CALL console_write_string                    ; console_write_string uses the zero terminated 
006a			                                                 ; string after the CALL 
006a 1b .. 2a 3f	    DB 1Bh,"=", 0x20 + 0xa, 0x20 + 0x1f          ; ESC code, move to line 10, column 31 
006e ..			    DB "*     KAYPRO      *" 
0081 1b .. 2d 34	    DB 1Bh,"=", 0x20 + 0xd, 0x20 + 0x14          ; ESC code, move to line 13, column 20 
0085 ..			    DB " Please place your diskette into Drive A" 
00ad 08			    DB 0x8                                       ; Cursor 
00ae 00			    DB 0                                         ; End NUL terminated string 
00af			 
00af			    ; Read the first sector of the boot disk 
00af 0e 00		    LD C,0x0 
00b1 cd c3 01		    CALL EP_SELDSK 
00b4 01 00 00		    LD BC,0x0 
00b7 cd db 01		    CALL EP_SETTRK 
00ba 0e 00		    LD C,0x0 
00bc cd ca 01		    CALL EP_SETSEC 
00bf 01 00 fa		    LD BC, first_sector_load_address 
00c2 cd d6 01		    CALL EP_SETDMA 
00c5 cd fb 01		    CALL EP_READ 
00c8 f3			    DI 
00c9			    ; Verify the result 
00c9 b7			    OR A 
00ca 20 3e		    JR NZ, error_bad_disk 
00cc			    ; Set the DMA destination as instructed by the info 
00cc			    ; on the first boot sector 
00cc ed 4b 02 fa	    LD BC, (address_to_load_second_sector) 
00d0 ed 43 14 fc	    LD (disk_DMA_address), BC 
00d4			    ; Store the boot exec addres on the stack. A RET will 
00d4			    ; use this address and start executionthere 
00d4 ed 4b 04 fa	    LD BC, (address_to_exec_boot) 
00d8 c5			    PUSH BC 
00d9			    ; Prepare the loading of the rest of the sectors 
00d9 ed 4b 06 fa	    LD BC, (count_of_boot_sectors_needed) 
00dd 41			    LD B,C 
00de			    ; Continue reading from sector 1 
00de 0e 01		    LD C,0x1 
00e0			read_another_boot_sector: 
00e0			    ; B has the count of sectors remaining 
00e0			    ; C has the current sector number 
00e0 c5			    PUSH BC 
00e1			    ; Load sector C 
00e1 cd ca 01		    CALL EP_SETSEC 
00e4 cd fb 01		    CALL EP_READ 
00e7 f3			    DI 
00e8			    ; Verify the result 
00e8 c1			    POP BC 
00e9 b7			    OR A 
00ea 20 1e		    JR NZ, error_bad_disk 
00ec			    ; Increase by 128 the load address (logical sector size is 128 bytes) 
00ec 2a 14 fc		    LD HL, (disk_DMA_address) 
00ef 11 80 00		    LD DE, logical_sector_size 
00f2 19			    ADD HL,DE                                     
00f3 22 14 fc		    LD (disk_DMA_address), HL 
00f6			    ; Decrease the count of sectors remaining 
00f6 05			    DEC B 
00f7			    ; If done , jump to the boot exec address previously pushed to the stack 
00f7 c8			    RET Z 
00f8			    ; Not finished, calculate the next sector and track 
00f8 0c			    INC C 
00f9 3e 28		    LD A, sectors_per_track_double_density 
00fb			    ; Are we on the last sector of the track? 
00fb b9			    CP C 
00fc			    ; No, continue reading sector + 1 
00fc 20 e2		    JR NZ,read_another_boot_sector 
00fe			    ; Yes, track 0 completed. Continue with track 1, sector 16 
00fe 0e 10		    LD C,0x10                                     
0100 c5			    PUSH BC 
0101			    ; Move to track 1 
0101 01 01 00		    LD BC,0x0001 
0104 cd db 01		    CALL EP_SETTRK 
0107 c1			    POP BC 
0108			    ; Loop 
0108 18 d6		    JR read_another_boot_sector 
010a			 
010a			error_bad_disk: 
010a			    ; Error, write the error message and stop 
010a cd 85 08		    CALL console_write_string 
010d .. 00		    DB "\n\r\n\r\aI cannot read your diskette.",0 
012f cd b1 04		    CALL EP_DISKOFF 
0132			wait_forever: 
0132			    ; Lock the CPU forever 
0132 18 fe		    JR wait_forever 
0134			 
0134			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0134			; INIT DISK. COPY CODE AND DISK PARAMS TO UPPER RAM. RESET VARIABLES 
0134			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0134			; See CP/M 2.2 System alteration guide, section 10 
0134			 
0134			; This data will be copied starting 0xfe79 
0134			disk_params: 
0134			init_disk_parameter_header_0: ; to 0xfe79 
0134 00 00		    DW 0x0000 ; XLT, logical translation table 
0136 00 00 00 00 00 00	    DW 0x0000, 0x0000, 0x0000 ; Scrathpad for BDOS 
013c 6d ff		    DW DIRBUF ; Address of additional scratchpad for BDOS, 
013e aa fe		    DW disk_parameter_block_double_density ; DPB 
0140 20 fe		    DW CSV_0 
0142 30 fe		    DW ALV_0 
0144 00			    DB 0x00 ; Used by the BIOS to store the disk density 
0145			 
0145			init_disk_parameter_header_1: ; to 0xfe8a 
0145 00 00		    DW 0x0000 ; XLT, logical translation table 
0147 00 00 00 00 00 00	    DW 0x0000, 0x0000, 0x0000 ; Scrathpad for BDOS 
014d 6d ff		    DW DIRBUF ; Address of additional scratchpad for BDOS, 
014f aa fe		    DW disk_parameter_block_double_density ; DPB 
0151 4a fe		    DW CSV_1 
0153 5a fe		    DW ALV_1 
0155 00			    DB 0x00 ; Used by the BIOS to store the disk density 
0156			 
0156			; Single density disk 
0156			;   18 sectors (of 128 bytes) per track 
0156			;   1024 bytes per allocation block 
0156			;   83 kb total disk space 
0156			;   40 tracks, 3 reserved 
0156			init_disk_parameter_block_single_density: ; to 0xfe9b 
0156 12 00		    DW 18   ; SPT, sectors per track 
0158 03			    DB 3    ; BSH, data alloc shift factor 
0159 07			    DB 7    ; BLM 
015a			    ; As BSH=3 and BLM=7, then BLS (data alocation size) is 1024. 
015a 00			    DB 0    ; EXM, extent mask 
015b 52 00		    DW 82   ; DSM, total storage in allocation blocks - 1 
015d 1f 00		    DW 31   ; DRM, number of directory entries - 1 
015f 80			    DB 0x80 ; AL0 
0160 00			    DB 0x00 ; AL1 
0161 08 00		    DW 8    ; CKS, directory check vector size 
0163 03 00		    DW 3    ; OFF, number of reserved tracks 
0165			 
0165			; Single density disk 
0165			;   40 sectors (128 bytes) per track 
0165			;   1024 bytes per allocation block 
0165			;   195 kb total disk space 
0165			;   40 tracks, 1 reserved 
0165			init_disk_parameter_block_double_density: ; to 0xfeaa 
0165 28 00		    DW 40   ; SPT, sectors per track 
0167 03			    DB 3    ; BSH, data alloc shift factor 
0168 07			    DB 7    ; BLM 
0169			    ; As BSH=3 and BLM=7, then BLS (data alocation size) is 1024. 
0169 00			    DB 0    ; EXM, extent mask 
016a c2 00		    DW 194  ; DSM, total storage in allocation blocks - 1 
016c 3f 00		    DW 63   ; DRM, number of directory entries - 1 
016e f0			    DB 0xF0 ; AL0 
016f 00			    DB 0x00 ; AL1 
0170 10 00		    DW 16   ; CKS, directory check vector size 
0172 01 00		    DW 1    ; OFF, number of reserved tracks 
0174			 
0174			init_sector_translation_table: ; 0xfeb9 
0174			    ; Only used for single density 
0174			    ; There is translation for 18 sectors. 
0174 01 06 0b 10 03 08 0d 12	    DB 1, 6, 11, 16, 3, 8, 13, 18 
017c 05 0a 0f 02 07 0c 11 04	    DB 5, 10, 15, 2, 7, 12, 17, 4 
0184 09 0e		    DB 9, 14 
0186			disk_params_end: 
0186			 
0186			init_disk_parameter_block_double_density_double_side: 
0186 28 00		    DW 40   ; SPT, sectors per track  
0188 04			    DB 4    ; BSH, data alloc shift factor  
0189 0f			    DB 15   ; BLM 
018a			    ; As BSH=4 and BLM=15, then BLS (data alocation size) is 2048. 
018a 01			    DB 1    ; EXM, extent mask  
018b c4 00		    DW 196  ; DSM, total storage in allocation blocks - 1 
018d 3f 00		    DW 63   ; DRM, number of directory entries - 1 
018f c0			    DB 0xC0 ; AL0 
0190 00			    DB 0x00 ; AL1  
0191 10 00		    DW 16   ; CKS, directory check vector size 
0193 01 00		    DW 1    ; OFF, number of reserved tracks 
0195			 
0195			EP_INITDSK: 
0195			    ; Copy relocatable disk access to upper RAM to 
0195			    ; be accessible even when the ROM is swapped out 
0195 21 3b 05		    LD HL, block_to_relocate 
0198 11 d1 fe		    LD DE, relocation_destination 
019b 01 87 00		    LD BC, block_to_relocate_end - block_to_relocate ;0x87 
019e ed b0		    LDIR 
01a0			 
01a0			    ; Copy the disk parameters to upper RAM 
01a0 21 34 01		    LD HL, disk_params 
01a3 11 79 fe		    LD DE, disk_params_destination 
01a6 01 52 00		    LD BC, disk_params_end - disk_params ;0x52 
01a9 ed b0		    LDIR 
01ab			 
01ab			    ; Init some variables 
01ab af			    XOR A 
01ac 32 09 fc		    LD (fdc_set_flag), A ; = No 
01af 32 0b fc		    LD (pending_count), A ; = 0 
01b2 3e 00		    LD A, disk_density_double 
01b4 32 18 fe		    LD (disk_density), A 
01b7 3e ff		    LD A, disk_active_info_undefined 
01b9 32 16 fe		    LD (disk_active_drive), A 
01bc 32 1a fe		    LD (disk_active_info_drive_a), A 
01bf 32 1d fe		    LD (disk_active_info_drive_b), A 
01c2 c9			    RET 
01c3			 
01c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
01c3			; FLOPPY DISK ENTRY POINTS 
01c3			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
01c3			 
01c3			EP_SELDSK: 
01c3			    ; C: disk number 
01c3 79			    LD A,C 
01c4 32 00 fc		    LD (drive_selected), A 
01c7 c3 2c 03		    JP init_drive 
01ca			 
01ca			EP_SETSEC: 
01ca			    ; BC: sector number 
01ca 79			    LD A,C 
01cb 32 03 fc		    LD (sector_selected), A 
01ce			    ; Is the disk double density? 
01ce 3a 18 fe		    LD A, (disk_density) 
01d1 b7			    OR A 
01d2			    ; No, send the sector to the controller 
01d2 c2 6d 04		    JP NZ, fdc_set_sector 
01d5			    ; Yes, we just store the sector number 
01d5 c9			    RET 
01d6			 
01d6			EP_SETDMA: 
01d6			    ; BC: DMA address 
01d6 ed 43 14 fc	    LD (disk_DMA_address), BC 
01da c9			    RET 
01db			 
01db			EP_SETTRK: 
01db			    ; C: track number 
01db ed 43 01 fc	    LD (track_selected), BC 
01df			    ; Is the disk double density? 
01df 3a 18 fe		    LD A, (disk_density) 
01e2 b7			    OR A 
01e3			    ; No, send the track to the controller 
01e3 c2 49 04		    JP NZ, fdc_seek_track 
01e6			    ; Yes, we just store the track number 
01e6 c9			    RET 
01e7			 
01e7			EP_HOME: 
01e7			    ;Is the disk double density? 
01e7 3a 18 fe		    LD A, (disk_density) 
01ea b7			    OR A 
01eb			    ; No, go to track 0 and return 
01eb c2 36 04		    JP NZ, fdc_seek_track_0 
01ee			    ; Yes. 
01ee			    ; Is a write pending? 
01ee 3a 0a fc		    LD A,(pending_write_flag) 
01f1 b7			    OR A 
01f2			    ; Yes, skip update 
01f2 c2 f8 01		    JP NZ, skip_buffer_discard 
01f5			    ; No, discard the buffer 
01f5 32 09 fc		    LD (fdc_set_flag),A ; = No 
01f8			skip_buffer_discard: 
01f8 c3 36 04		    JP fdc_seek_track_0 
01fb			 
01fb			EP_READ: 
01fb			    ; Is disk double density? 
01fb 3a 18 fe		    LD A,(disk_density) 
01fe b7			    OR A 
01ff			    ; No, go directly to the read routine 
01ff c2 e0 fe		    JP NZ, read_single_density_relocated 
0202			    ; Yes, some preparation is needed as the calls to EP_SETSEC and 
0202			    ; EP_SETTRK did not send the info to the fdc for double density. 
0202			    ; Init variables 
0202 af			    XOR A 
0203 32 0b fc		    LD (pending_count),A ; = 0 
0206			    ; Starting from here it is equal to read in Appendix G 
0206 3e 01		    LD A, operation_type_read 
0208 32 12 fc		    LD (operation_type), A; = operation_type_read 
020b 32 11 fc		    LD (read_needed_flag), A ; = read_needed 
020e 3e 02		    LD A, rw_type_read_or_unallocated_write 
0210 32 13 fc		    LD (rw_type),A 
0213 c3 88 02		    JP read_write_double_density 
0216			 
0216			EP_WRITE: 
0216			    ; C indicates the rw_type 
0216			    ; Is disk double density? 
0216 3a 18 fe		    LD A,(disk_density) 
0219 b7			    OR A 
021a			    ; No, go directly to the write routine 
021a c2 f1 fe		    JP NZ, write_single_density_relocated 
021d			    ; Yes, some preparation is needed as the calls to EP_SETSEC and 
021d			    ; set_track did not send the info to the fdc on double density. 
021d			    ; Starting from here it is equal to read in Appendix G 
021d af			    XOR A 
021e 32 12 fc		    LD (operation_type), A ; = operation_type_write 
0221 79			    LD A,C 
0222 32 13 fc		    LD (rw_type),A ; = C 
0225 fe 02		    CP rw_type_read_or_unallocated_write 
0227			    ; It's an allocated write, we can skip reset the 
0227			    ; unallocated params to check if a read is needed. 
0227 c2 41 02		    JP NZ, write_check_read_needed 
022a 3e 08		    LD A, double_density_sector_size / logical_sector_size ; 8 
022c 32 0b fc		    LD (pending_count),A ; = 8 
022f			    ; Initialize the unallocated params 
022f 3a 00 fc		    LD A, (drive_selected) 
0232 32 0c fc		    LD (drive_unallocated), A 
0235 2a 01 fc		    LD HL, (track_selected) 
0238 22 0d fc		    LD (track_unallocated), HL 
023b 3a 03 fc		    LD A, (sector_selected) 
023e 32 0f fc		    LD (sector_unallocated), A 
0241			write_check_read_needed: 
0241			    ; Do we have pending logical sectors? 
0241 3a 0b fc		    LD A,(pending_count) 
0244 b7			    OR A 
0245			    ; No, skip 
0245 ca 80 02		    JP Z, write_with_read_needed 
0248			    ; Yes, there are more unallocated records remaining 
0248 3d			    DEC A 
0249 32 0b fc		    LD (pending_count),A ; pending_count-1 
024c			    ; Is drive requested different to the unallocated? 
024c 3a 00 fc		    LD A, (drive_selected) 
024f 21 0c fc		    LD HL, drive_unallocated 
0252 be			    CP (HL) 
0253			    ; Yes, the drive is different 
0253 c2 80 02		    JP NZ, write_with_read_needed 
0256			    ; The drives are the same 
0256			    ; Is track requested different to the unallocated? 
0256 21 0d fc		    LD HL, track_unallocated 
0259 cd 20 03		    CALL is_track_equal_to_track_selected 
025c			    ; Yes, the track is different 
025c c2 80 02		    JP NZ, write_with_read_needed 
025f			    ; The tracks are the same 
025f			    ; Is sector requested different to the unallocated? 
025f 3a 03 fc		    LD A, (sector_selected) 
0262 21 0f fc		    LD HL, sector_unallocated 
0265 be			    CP (HL) 
0266			    ; Yes, the sector is different 
0266 c2 80 02		    JP NZ, write_with_read_needed 
0269			    ; The sectors are the same 
0269			    ; DTS on the unallocated variables match the requested DTS 
0269			    ; Advance to the next sector to check if the next write will 
0269			    ; be of the next sector. 
0269 34			    INC (HL) 
026a			    ; Are we at the end of the track? 
026a 7e			    LD A,(HL) 
026b fe 28		    CP sectors_per_track_double_density 
026d			    ; No 
026d da 79 02		    JP C, write_with_read_not_needed 
0270			    ; Yes, increase track and set sector to zero 
0270 36 00		    LD (HL),0x0 
0272 2a 0d fc		    LD HL, (track_unallocated) 
0275 23			    INC HL 
0276 22 0d fc		    LD (track_unallocated),HL 
0279			write_with_read_not_needed: 
0279 af			    XOR A 
027a 32 11 fc		    LD (read_needed_flag),A ; = read_not_needed 
027d c3 88 02		    JP read_write_double_density 
0280			write_with_read_needed: 
0280 af			    XOR A 
0281 32 0b fc		    LD (pending_count),A ; = 0 
0284 3c			    INC A 
0285 32 11 fc		    LD (read_needed_flag),A ; = read_needed 
0288			 
0288			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0288			; FLOPPY DISK INTERNAL IMPLEMENTATION READ AND WRITE 
0288			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0288			     
0288			read_write_double_density: 
0288			    ; Reset the result variable 
0288 af			    XOR A 
0289 32 10 fc		    LD (rw_result),A ; = 0 
028c			    ; Translate the sector logical address to the double density 
028c			    ; address. As sector in DD are four times the size of sector 
028c			    ; in SD, we divide by 4 (or shift right twice). 
028c			    ; Sure? Ono some places its 8 times ??? 
028c 3a 03 fc		    LD A, (sector_selected) 
028f b7			    OR A ; Clear carry 
0290 1f			    RRA ; /2 
0291 b7			    OR A ; Clear carry 
0292 1f			    RRA ; /2 
0293 32 08 fc		    LD (dd_sector_selected),A ; sector_selected / 4 
0296			    ; Is fcd_position set 
0296 21 09 fc		    LD HL, fdc_set_flag 
0299 7e			    LD A,(HL) 
029a 36 01		    LD (HL),0x1 ; fdc_set_flag = Yes 
029c b7			    OR A 
029d			    ; No, continue after updating the DTS_in_fdc variables 
029d ca c4 02		    JP Z, rw_fdc_not_set 
02a0			    ; Yes 
02a0			    ; Are the fdc variables different from the selected? 
02a0 3a 00 fc		    LD A,(drive_selected) 
02a3 21 04 fc		    LD HL, drive_in_fdc 
02a6 be			    CP (HL) 
02a7			    ; Yes, the drive is different 
02a7 c2 bd 02		    JP NZ, rw_fdc_mismatch 
02aa			    ; Is track requested different to the xx? 
02aa 21 05 fc		    LD HL, track_in_fdc 
02ad cd 20 03		    CALL is_track_equal_to_track_selected 
02b0			    ; Yes, the track is different 
02b0 c2 bd 02		    JP NZ, rw_fdc_mismatch 
02b3			    ; Is sector requested equals to the xx? 
02b3 3a 08 fc		    LD A, (dd_sector_selected) 
02b6 21 07 fc		    LD HL, sector_in_fdc 
02b9 be			    CP (HL) 
02ba			    ; Yes, the sector is equal 
02ba ca e1 02		    JP Z, rw_fdc_set 
02bd			rw_fdc_mismatch: 
02bd			    ; Is there a pending write on the buffer 
02bd 3a 0a fc		    LD A, (pending_write_flag) 
02c0 b7			    OR A 
02c1			    ; Yes, write the buffer before continuing 
02c1 c4 cc 04		    CALL NZ, write_from_buffer_with_retries 
02c4			    ; Now we can init the _in_fdc variables 
02c4			rw_fdc_not_set: 
02c4			    ; DTS_in_fdc = DTS_selected 
02c4 3a 00 fc		    LD A, (drive_selected) 
02c7 32 04 fc		    LD (drive_in_fdc),A 
02ca 2a 01 fc		    LD HL, (track_selected) 
02cd 22 05 fc		    LD (track_in_fdc),HL 
02d0 3a 08 fc		    LD A,(dd_sector_selected) 
02d3 32 07 fc		    LD (sector_in_fdc),A 
02d6			    ; Is a read needed 
02d6 3a 11 fc		    LD A,(read_needed_flag) 
02d9 b7			    OR A 
02da			    ; Yes, read to fill the buffer 
02da c4 0a 05		    CALL NZ, read_to_buffer_with_retries 
02dd af			    XOR A 
02de 32 0a fc		    LD (pending_write_flag),A ; = no pending write 
02e1			rw_fdc_set: 
02e1			    ; Calculate the sector buffer to use for this sector    
02e1 3a 03 fc		    LD A, (sector_selected) 
02e4 e6 03		    AND 0x3 ; mod 4 
02e6 6f			    LD L,A 
02e7 26 00		    LD H,0x0 
02e9 29			    ADD HL,HL ; *2 
02ea 29			    ADD HL,HL ; *2 
02eb 29			    ADD HL,HL ; *2 
02ec 29			    ADD HL,HL ; *2 
02ed 29			    ADD HL,HL ; *2 
02ee 29			    ADD HL,HL ; *2 
02ef 29			    ADD HL,HL ; *2. Combined *128 
02f0 11 16 fc		    LD DE, sector_buffer_base 
02f3 19			    ADD HL,DE 
02f4			    ; HL = sector_buffer_base + (sector mod 4) * logical_sector_size 
02f4 ed 5b 14 fc	    LD DE,(disk_DMA_address) 
02f8 01 80 00		    LD BC,logical_sector_size 
02fb			    ; 
02fb 3a 12 fc		    LD A,(operation_type) 
02fe b7			    OR A 
02ff			    ; Yes, it's a read, skip write related coe 
02ff 20 06		    JR NZ, copy_block_to_or_from_buffer 
0301 3e 01		    LD A,0x1 
0303 32 0a fc		    LD (pending_write_flag),A ; = 1 
0306			    ; Reverse the block copy direction 
0306 eb			    EX DE,HL 
0307			copy_block_to_or_from_buffer: 
0307			    ; Copy a sector from the buffer to the DMA 
0307 cd d1 fe		    CALL move_RAM_relocated 
030a 3a 13 fc		    LD A, (rw_type) 
030d fe 01		    CP rw_type_directory_write 
030f 3a 10 fc		    LD A, (rw_result) 
0312			    ; Return if it is a read or a normal write 
0312 c0			    RET NZ 
0313 b7			    OR A 
0314			    ; Return if last read/write had an error 
0314 c0			    RET NZ 
0315			    ; It is a directory write. Le's not wait and 
0315			    ; save to disk now. (to be more reliable?) 
0315 af			    XOR A 
0316 32 0a fc		    LD (pending_write_flag),A ; = 0 
0319 cd cc 04		    CALL write_from_buffer_with_retries 
031c 3a 10 fc		    LD A,(rw_result) 
031f c9			    RET 
0320			 
0320			is_track_equal_to_track_selected: 
0320			    ; HL = address to a variable with the track 
0320			    ; Returns flag Z set if they are equal. 
0320			    ; This is not inline as the drive and sector comparison because 
0320			    ; the track is two bytes. 
0320 eb			    EX DE,HL 
0321 21 01 fc		    LD HL, track_selected 
0324 1a			    LD A,(DE) ; = track 
0325 be			    CP (HL) 
0326 c0			    RET NZ 
0327 13			    INC DE 
0328 23			    INC HL 
0329 1a			    LD A,(DE) 
032a be			    CP (HL) 
032b c9			    RET 
032c			 
032c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
032c			; FLOPPY DISK INTERNAL INIT 
032c			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
032c			 
032c			init_drive: 
032c			    ; Change current drive, update the disk info and check density 
032c			    ; C: drive number  
032c 21 00 00		    LD HL,0x0 
032f 79			    LD A,C 
0330 fe 02		    CP disk_count 
0332			    ; Ignore if the drive number is out of range 
0332 d0			    RET NC 
0333			    ; Point HL to the disk info for disk A or B 
0333 b7			    OR A 
0334 21 79 fe		    LD HL, disk_parameter_header_0 
0337 28 03		    JR Z, disk_params_skip_for_drive_a 
0339 21 8a fe		    LD HL, disk_parameter_header_1 
033c			disk_params_skip_for_drive_a: 
033c			    ; The current drive is the requested one? 
033c 3a 16 fe		    LD A,(disk_active_drive) 
033f b9			    CP C 
0340			    ; Yes, nothing to do 
0340 c8			    RET Z 
0341			    ; No, change the drive 
0341			    ; Store the new drive number 
0341 79			    LD A,C 
0342 32 16 fe		    LD (disk_active_drive),A 
0345 b7			    OR A 
0346			    ; If the disk info for the drive is defined, 
0346			    ; restore that as the active info 
0346 e5			    PUSH HL 
0347 21 17 fe		    LD HL, disk_active_info 
034a 11 1d fe		    LD DE, disk_active_info_drive_b 
034d 28 03		    JR Z, save_previous_disk_info 
034f 11 1a fe		    LD DE, disk_active_info_drive_a 
0352			save_previous_disk_info: 
0352 1a			    LD A, (DE) 
0353			    ; Is the active info undefined? 
0353 fe ff		    CP disk_active_info_undefined 
0355			    ; Yes, no need to save the info 
0355 28 0a		    JR Z, skip_save_disk_info 
0357 c5			    PUSH BC 
0358			    ; Save the current disk info for the drive 
0358 01 03 00		    LD BC, 0x3 
035b ed b0		    LDIR 
035d c1			    POP BC 
035e 11 17 fe		    LD DE, disk_active_info 
0361			skip_save_disk_info: 
0361			    ; C is the disk number 
0361 79			    LD A,C 
0362 b7			    OR A 
0363			    ; Load active info for disk a or b 
0363 21 1a fe		    LD HL, disk_active_info_drive_a 
0366 28 03		    JR Z, load_previous_info 
0368 21 1d fe		    LD HL, disk_active_info_drive_b 
036b			load_previous_info: 
036b 7e			    LD A,(HL) 
036c			    ; Is the stored info undefined? 
036c fe ff		    CP disk_active_info_undefined 
036e			    ; Yes, the info is not cached, we need to analyze the disk 
036e 28 20		    JR Z, analyze_inserted_disk 
0370			    ; Restore the disk info 
0370 01 03 00		    LD BC, 0x3 
0373 ed b0		    LDIR 
0375			    ; Copy the required disk parameter block DDSD or DDDD 
0375 01 0f 00		    LD BC, disk_parameter_block_size 
0378 11 aa fe		    LD DE, disk_parameter_block_double_density 
037b 21 65 01		    LD HL, init_disk_parameter_block_double_density 
037e 3a 19 fe		    LD A, (disk_active_has_sides) 
0381 b7			    OR A 
0382 28 03		    JR Z, skip_for_single_side 
0384 21 86 01		    LD HL, init_disk_parameter_block_double_density_double_side 
0387			skip_for_single_side: 
0387 ed b0		    LDIR ; Copy the parameter block 
0389			    ; Restore the track position 
0389 3a 17 fe		    LD A, (disk_active_track) 
038c d3 11		    OUT (io_11_fdc_track), A 
038e e1			    POP HL 
038f c9			    RET 
0390			 
0390			analyze_inserted_disk: 
0390 e1			    POP HL 
0391			    ; Try reading as double density disk 
0391 3e 00		    LD A, disk_density_double 
0393 32 18 fe		    LD (disk_density), A 
0396 cd 84 04		    CALL prepare_drive 
0399 cd e7 01		    CALL EP_HOME 
039c cd 1d 04		    CALL fdc_read_address 
039f			    ; If it reads the track, it is a double density disk 
039f 28 0e		    JR Z, set_double_density_disk 
03a1			    ; No, try reading as single density disk 
03a1 3e 20		    LD A, disk_density_single 
03a3 32 18 fe		    LD (disk_density), A 
03a6 cd 84 04		    CALL prepare_drive 
03a9 cd 1d 04		    CALL fdc_read_address 
03ac c0			    RET NZ ; Return if it fails as single and double density disk 
03ad 18 43		    JR set_single_density_disk 
03af			 
03af			set_double_density_disk: 
03af			    ; HL is disk_parameter_header 
03af e5			    PUSH HL 
03b0 d5			    PUSH DE 
03b1			    ; Set no sector tran on the disk params $0 and $1 
03b1 11 00 00		    LD DE,0x0000 
03b4 73			    LD (HL),E 
03b5 23			    INC HL 
03b6 72			    LD (HL),D 
03b7			    ; Set DPB for double density on the disk params $a and $b 
03b7 11 09 00		    LD DE,0x0009 
03ba 19			    ADD HL,DE 
03bb 11 aa fe		    LD DE, disk_parameter_block_double_density 
03be 73			    LD (HL),E 
03bf 23			    INC HL 
03c0 72			    LD (HL),D 
03c1			    ; Select disk side 2, will be change to side 1 later. 
03c1 db 1c		    IN A,(io_1c_system_bits) 
03c3 f6 04		    OR system_bit_side_2_mask 
03c5 d3 1c		    OUT (io_1c_system_bits),A 
03c7			    ; Try reading on the side 2 
03c7 cd 1d 04		    CALL fdc_read_address 
03ca 01 0f 00		    LD BC, disk_parameter_block_size 
03cd 11 aa fe		    LD DE, disk_parameter_block_double_density 
03d0 21 65 01		    LD HL, init_disk_parameter_block_double_density 
03d3 3e 00		    LD A, disk_active_has_sides_no 
03d5			    ; If it fails, side 2 is not readable we are for sure on a single side disk 
03d5 20 0e		    JR NZ, second_side_analysis_completed 
03d7			    ; The previous fdc_read_address has not failed: there is valid 
03d7			    ; info on the side 2.  
03d7			    ; We will see if the sector number to check if it is a single side disk 
03d7			    ; reversed or if it is the side 2 of a double sided disk. 
03d7			    ; As we have loaded the sector info, on the 3rd byte  we have the  
03d7			    ; sector number. On a second side the sector goes from 10 to 29. 
03d7 3a cd fe		    LD A, (disk_read_address_sector) 
03da			    ; Is the sector number less than 10? 
03da fe 0a		    CP tracks_per_side 
03dc 3e 00		    LD A, disk_active_has_sides_no 
03de			    ; Yes it is less than 10, it's is not a two sided disk 
03de 38 05		    JR C, second_side_analysis_completed 
03e0 21 86 01		    LD HL, init_disk_parameter_block_double_density_double_side 
03e3 3e ff		    LD A, disk_active_has_sides_yes 
03e5			second_side_analysis_completed: 
03e5			    ; Store the result of the side analyis 
03e5 32 19 fe		    LD (disk_active_has_sides), A 
03e8			    ; Copy the disk param block required DDSD or DDDD 
03e8 ed b0		    LDIR 
03ea			    ; Go back to side 1 
03ea db 1c		    IN A,(io_1c_system_bits) 
03ec e6 fb		    AND ~system_bit_side_2_mask 
03ee d3 1c		    OUT (io_1c_system_bits),A 
03f0 18 12		    JR finish_set_single_or_double_density_disk 
03f2			 
03f2			set_single_density_disk: 
03f2			    ; HL is disk_parameter_header 
03f2 e5			    PUSH HL 
03f3 d5			    PUSH DE 
03f4			    ; Set the sector translation table on the disk params $0 and $1 
03f4 11 b9 fe		    LD DE, disk_sector_translation_table 
03f7 73			    LD (HL),E 
03f8 23			    INC HL 
03f9 72			    LD (HL),D 
03fa			    ; Set the DPB on the disk params $a and $b 
03fa 11 09 00		    LD DE,0x0009 
03fd 19			    ADD HL,DE 
03fe 11 9b fe		    LD DE, disk_parameter_block_single_density 
0401 73			    LD (HL),E 
0402 23			    INC HL 
0403 72			    LD (HL),D 
0404			 
0404			finish_set_single_or_double_density_disk: 
0404			    ; Copy  
0404 21 17 fe		    LD HL, disk_active_info 
0407 11 1a fe		    LD DE, disk_active_info_drive_a 
040a 3a 16 fe		    LD A, (disk_active_drive) 
040d b7			    OR A 
040e 28 03		    JR Z, skip_for_drive_a_bis 
0410 11 1d fe		    LD DE, disk_active_info_drive_b 
0413			skip_for_drive_a_bis: 
0413 c5			    PUSH BC 
0414 01 03 00		    LD BC, 0x3 
0417 ed b0		    LDIR 
0419 c1			    POP BC 
041a d1			    POP DE 
041b e1			    POP HL 
041c c9			    RET 
041d			 
041d			fdc_read_address: 
041d			    ; This is used to confirm that the disk is readable as configured 
041d			    ; for single or double density.  
041d e5			    PUSH HL 
041e c5			    PUSH BC 
041f 21 cb fe		    LD HL, disk_read_address_buffer 
0422 01 13 06		    LD BC, disk_read_address_buffer_size*0x100 + io_13_fdc_data 
0425 3e c4		    LD A, fdc_command_read_address 
0427 d3 10		    OUT (io_10_fdc_command), A 
0429			wait_for_data: 
0429 76			    HALT 
042a ed a2		    INI 
042c 20 fb		    JR NZ, wait_for_data 
042e cd c4 04		    CALL wait_for_result 
0431			    ; Is record not found? 
0431 cb 67		    BIT fdc_status_record_not_found_bit, A 
0433 c1			    POP BC 
0434 e1			    POP HL 
0435 c9			    RET 
0436			 
0436			fdc_seek_track_0: 
0436 cd 84 04		    CALL prepare_drive 
0439			    ; Go to the first side of the disk 
0439 db 1c		    IN A,(io_1c_system_bits) 
043b e6 fb		    AND ~system_bit_side_2_mask 
043d d3 1c		    OUT (io_1c_system_bits),A 
043f			    ; Set active track to 0 
043f af			    XOR A 
0440 32 17 fe		    LD (disk_active_track), A 
0443 3e 00		    LD A, fdc_command_restore 
0445 d3 10		    OUT (io_10_fdc_command), A 
0447 18 7b		    JR wait_for_result 
0449			 
0449			fdc_seek_track: 
0449			    ; C: track number 
0449 cd 84 04		    CALL prepare_drive 
044c 3a 19 fe		    LD A, (disk_active_has_sides) 
044f b7			    OR A 
0450 28 0f		    JR Z, skip_disk_side_change 
0452 79			    LD A , C 
0453 1f			    RRA 
0454 4f			    LD C, A 
0455 db 1c		    IN A,(io_1c_system_bits) 
0457 38 04		    JR C, select_disk_side_2 
0459			    ; Selet disk side 1 
0459 e6 fb		    AND  ~system_bit_side_2_mask 
045b 18 02		    JR update_disk_side 
045d			select_disk_side_2: 
045d			    ; Select disk side 2 
045d f6 04		    OR system_bit_side_2_mask 
045f			update_disk_side: 
045f d3 1c		    OUT (io_1c_system_bits),A 
0461			skip_disk_side_change: 
0461 79			    LD A, C 
0462 32 17 fe		    LD (disk_active_track), A 
0465 d3 13		    OUT (io_13_fdc_data),A 
0467 3e 10		    LD A, fdc_command_seek 
0469 d3 10		    OUT (io_10_fdc_command),A 
046b 18 57		    JR wait_for_result 
046d			 
046d			fdc_set_sector: 
046d			    ; C = sector 
046d db 1c		    IN A,(io_1c_system_bits) 
046f cb 57		    BIT system_bit_side_2, A 
0471 79			    LD A,C 
0472 28 02		    JR Z, skip_for_side_1 
0474 c6 0a		    ADD A, tracks_per_side ; For tracks on the other side of the disk we add 10  
0476			skip_for_side_1: 
0476 d3 12		    OUT (io_12_fdc_sector),A 
0478 c9			    RET 
0479			 
0479			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0479			; FLOPPY DISK MORE ENTRYPOINTS 
0479			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0479			 
0479			EP_SECTRAN: 
0479			    ; BC = sector 
0479			    ; DE = pointer to the translation table 
0479			    ; Returns in HL the translated sector 
0479 7a			    LD A,D 
047a b3			    OR E 
047b 60			    LD H,B 
047c 69			    LD L,C ; HL = BC; Why is this needed? 
047d			    ; Return if there is no translation table (DE=0x0000) 
047d c8			    RET Z 
047e eb			    EX DE,HL ; HL <> DE 
047f 09			    ADD HL,BC ; HL = sector + BC 
0480 6e			    LD L,(HL) 
0481 26 00		    LD H,0x0 
0483 c9			    RET 
0484			 
0484			prepare_drive: 
0484			    ; 1: Interrupt any pending floppy disk controller command. 
0484 e5			    PUSH HL 
0485 d5			    PUSH DE 
0486 c5			    PUSH BC 
0487			    ; 1: Interrupt any pending floppy disk controller command. 
0487 3e d0		    LD A, fdc_command_force_interrupt 
0489 d3 10		    OUT (io_10_fdc_command), A 
048b			    ; 2: Start the motor 
048b cd a2 04		    CALL EP_DISKON 
048e			    ; 3; Update the systems bits for the proper selected drive and density. 
048e 3a 16 fe		    LD A, (disk_active_drive) 
0491 5f			    LD E,A 
0492 db 1c		    IN A,(io_1c_system_bits) 
0494			    ; Clear drive select bits 
0494 e6 dc		    AND ~ (system_bit_double_density_neg_mask|system_bit_drive_a_mask|system_bit_drive_b_mask) 
0496			    ; Add the bit of the drive selected 
0496 b3			    OR E 
0497 3c			    INC A ; disk A(0) to mask 0x1, disk B(1) to mask 0x2 
0498			    ; Reflect the disk density variable on the system bits. 
0498 21 18 fe		    LD HL, disk_density 
049b b6			    OR (HL) 
049c			    ; Store the modified system bits 
049c d3 1c		    OUT (io_1c_system_bits), A 
049e c1			    POP BC 
049f d1			    POP DE 
04a0 e1			    POP HL 
04a1 c9			    RET 
04a2			 
04a2			EP_DISKON: 
04a2			    ; Turns the motor on, if it is already on it can return immediately. 
04a2			    ; It was off, it is started and there is a delay yo let the motors 
04a2			    ; get some speed. 
04a2			    ; 
04a2			    ; Is it already on? 
04a2 db 1c		    IN A,(io_1c_system_bits) 
04a4 cb 77		    BIT system_bit_motors_neg,A 
04a6			    ; Yes, return 
04a6 c8			    RET Z 
04a7			    ; No, turn on 
04a7 cb b7		    RES system_bit_motors_neg,A 
04a9 d3 1c		    OUT (io_1c_system_bits),A 
04ab			    ; Wait for the motor to get some speed 
04ab 06 32		    LD B,0x32; 500ms delay 
04ad cd b8 04		    CALL EP_DELAY 
04b0 c9			    RET 
04b1			 
04b1			EP_DISKOFF: 
04b1			    ; Turn off in any case 
04b1 db 1c		    IN A,(io_1c_system_bits) 
04b3 cb f7		    SET system_bit_motors_neg,A 
04b5 d3 1c		    OUT (io_1c_system_bits),A 
04b7 c9			    RET 
04b8			 
04b8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
04b8			; WAIT 
04b8			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
04b8			 
04b8			EP_DELAY: 
04b8			    ; wait time in B 
04b8 11 86 06		    LD DE,0x686 
04bb			EP_DELAY_inner_loop: 
04bb 1b			    DEC DE 
04bc 7a			    LD A,D 
04bd b3			    OR E 
04be c2 bb 04		    JP NZ, EP_DELAY_inner_loop 
04c1			    ; Do DELAY again with B-1 
04c1 10 f5		    DJNZ EP_DELAY 
04c3 c9			    RET 
04c4			 
04c4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
04c4			; FLOPPY DISK INTERNAL MORE IMPLEMENTATION READ AND WRITE 
04c4			; 
04c4			; Actual read and write used by the Appendix G algorithm 
04c4			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
04c4			 
04c4			wait_for_result: 
04c4			    ; The fdc generates a NMI when it requires attention. The NMI handler 
04c4			    ; is just a RET that will stop the HALT and execute the next instruction. 
04c4 76			    HALT 
04c5			wait_while_busy: 
04c5 db 10		    IN A,(io_10_fdc_status) 
04c7 cb 47		    BIT fdc_status_record_busy_bit, A 
04c9 20 fa		    JR NZ,wait_while_busy 
04cb c9			    RET 
04cc			 
04cc			write_from_buffer_with_retries: 
04cc 2e 03		    LD L, 3 ; retry 3 times if verification fails 
04ce			write_full_retry: 
04ce 11 0f 04		    LD DE,0x040f ; retry 15 times without seek. Repeat all up to 4 times with seek0 
04d1			write_retry: 
04d1 e5			    PUSH HL 
04d2 d5			    PUSH DE 
04d3 cd 25 05		    CALL fcd_seek_sector 
04d6 cd f8 fe		    CALL write_from_buffer_relocated 
04d9 d1			    POP DE 
04da e1			    POP HL 
04db			    ; If write success, verify the write 
04db 28 0d		    JR Z, verify_write 
04dd 1d			    DEC E 
04de			    ; Retry without moving the head home 
04de 20 f1		    JR NZ, write_retry 
04e0 15			    DEC D 
04e1			    ; Do not retry anymore 
04e1 28 1c		    JR Z, process_result 
04e3			    ; Mode the head to track 0 to retry making sure the head is moved. 
04e3 cd 36 04		    CALL fdc_seek_track_0 
04e6 1e 0f		    LD E,0xf 
04e8 18 e7		    JR write_retry 
04ea			 
04ea			verify_write: 
04ea 06 00		    LD B,0x0 ; loop for 256 bytes 
04ec 3e 88		    LD A, fdc_command_read_sector 
04ee d3 10		    OUT (io_10_fdc_command),A 
04f0			read_first_256_bytes_loop: 
04f0			    ; Test read 256 bytes (B from 0 and back to 0) 
04f0 76			    HALT 
04f1 db 13		    IN A,(io_13_fdc_data) 
04f3 10 fb		    DJNZ read_first_256_bytes_loop 
04f5			read_second_256_bytes_loop: 
04f5			    ; Test read 256 bytes (B from 0 and back to 0) 
04f5 76			    HALT 
04f6 db 13		    IN A,(io_13_fdc_data) 
04f8 10 fb		    DJNZ read_second_256_bytes_loop 
04fa cd c4 04		    CALL wait_for_result 
04fd			    ; Use only the error related bits 
04fd e6 9c		    AND fdc_status_read_error_bitmask 
04ff			process_result: 
04ff 32 10 fc		    LD (rw_result),A 
0502			    ; No errors, return 
0502 c8			    RET Z 
0503			    ; If we have retries lett, retry 
0503 2d			    DEC L 
0504 20 c8		    JR NZ, write_full_retry 
0506			    ; No more retries, exit with error ff 
0506 3e ff		    LD A,0xff 
0508 18 f5		    JR process_result 
050a			 
050a			read_to_buffer_with_retries: 
050a			    ; Load a full 512 bytes double density sector in the buffer. 
050a			    ; It is retried 15*4 times. Every 15 tries the head is fully moved 
050a			    ; to track 0 and moved to the requested track. 
050a 11 0f 04		    LD DE,0x040f ; retry 15 times without seek. Repeat all up to 4 times with seek0 
050d			read_retry: 
050d d5			    PUSH DE 
050e cd 25 05		    CALL fcd_seek_sector 
0511			    ; Read 512 bytes 
0511 cd e7 fe		    CALL read_to_buffer_relocated 
0514 32 10 fc		    LD (rw_result), A 
0517 d1			    POP DE 
0518			    ; Read success, exit 
0518 c8			    RET Z 
0519 1d			    DEC E 
051a			    ; Retry without moving the head home 
051a 20 f1		    JR NZ,read_retry 
051c 15			    DEC D 
051d			    ; Do not retry anymore 
051d c8			    RET Z 
051e			    ; Mode the head to track 0 to retry making sure the head is moved. 
051e cd 36 04		    CALL fdc_seek_track_0 
0521 1e 0f		    LD E,0xf 
0523 18 e8		    JR read_retry 
0525			 
0525			fcd_seek_sector: 
0525			    ; Put the disk to the requested position 
0525 3a 04 fc		    LD A,(drive_in_fdc) 
0528 4f			    LD C,A 
0529 cd 2c 03		    CALL init_drive 
052c ed 4b 05 fc	    LD BC,(track_in_fdc) 
0530 cd 49 04		    CALL fdc_seek_track 
0533 3a 07 fc		    LD A,(sector_in_fdc) 
0536 4f			    LD C,A 
0537 cd 6d 04		    CALL fdc_set_sector 
053a c9			    RET 
053b			 
053b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
053b			; CODE RELOCATED TO UPPER RAM 
053b			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
053b			 
053b			block_to_relocate: 
053b			reloc_move_RAM: 
053b			    ; Hide the ROM 
053b db 1c		    IN A,(io_1c_system_bits) 
053d cb bf		    RES system_bit_bank,A 
053f d3 1c		    OUT (io_1c_system_bits),A 
0541			    ; Copy the bytes 
0541 ed b0		    LDIR 
0543			    ; Show the ROM 
0543 db 1c		    IN A,(io_1c_system_bits) 
0545 cb ff		    SET system_bit_bank,A 
0547 d3 1c		    OUT (io_1c_system_bits),A 
0549 c9			    RET 
054a			 
054a			reloc_read_single_density: 
054a			    ; Read 128 bytes into DMA 
054a 2a 14 fc		    LD HL,(disk_DMA_address) 
054d 06 01		    LD B, rw_mode_single_density 
054f 18 05		    JR reloc_read_internal 
0551			reloc_read_to_buffer: 
0551			    ; Read 512 bytes into buffer 
0551 21 16 fc		    LD HL, sector_buffer_base 
0554 06 04		    LD B, rw_mode_double_density 
0556			reloc_read_internal: 
0556			    ; Configure RW for read 
0556 11 88 9c		    LD DE, fdc_status_read_error_bitmask * 0x100 + fdc_command_read_sector 
0559 18 0f		    JR reloc_RW_internal 
055b			 
055b			reloc_write_single_density: 
055b			    ; Write 128 bytes from DMA 
055b 2a 14 fc		    LD HL, (disk_DMA_address) 
055e 06 01		    LD B, rw_mode_single_density 
0560 18 05		    JR reloc_write_internal 
0562			reloc_write_from_buffer: 
0562			    ; Write 512 bytes from buffer 
0562 21 16 fc		    LD HL, sector_buffer_base 
0565 06 04		    LD B, rw_mode_double_density 
0567			reloc_write_internal: 
0567			    ; Configure RW for write 
0567 11 ac fc		    LD DE, fdc_status_write_error_bitmask * 0x100 + fdc_command_write_sector 
056a			 
056a			reloc_RW_internal: 
056a cd 84 04		    CALL prepare_drive; Call in the ROM area 
056d f3			    DI 
056e			    ; Hide the ROM. No more calls to the ROM passed this instruction 
056e db 1c		    IN A,(io_1c_system_bits) 
0570 cb bf		    RES system_bit_bank,A 
0572 d3 1c		    OUT (io_1c_system_bits),A 
0574			    ; Setup RET as the handler of NMI 
0574			    ; As the ROM is paged out, there is no handler. 
0574 e5			    PUSH HL 
0575			    ; Store in A' the current first byte on 0x66 
0575 21 66 00		    LD HL, nmi_isr 
0578 7e			    LD A,(HL) 
0579 08			    EX AF,AF' ; ' 
057a			    ; Set RET as the handler of NMI 
057a 36 c9		    LD (HL), RET_opcode 
057c e1			    POP HL 
057d			    ; 
057d 78			    LD A,B ; A = rw_mode 
057e 01 13 80		    LD BC, logical_sector_size * 0x100 + io_13_fdc_data  ; Setup of the INI command 
0581 cb 47		    BIT 0x0,A  
0583 20 02		    JR NZ, read_rw_internal_cont 
0585			    ; For rw_mode_double_density let's set B to zero 
0585 06 00		    LD B,0x0 
0587			read_rw_internal_cont: 
0587			    ; Is mode single density? 
0587 fe 01		    CP rw_mode_single_density 
0589 f5			    PUSH AF 
058a 7b			    LD A,E 
058b			    ; Is the command a write? 
058b fe ac		    CP fdc_command_write_sector 
058d			    ; Yes, go to write 
058d 28 11		    JR Z, reloc_write_sector 
058f			    ; No, let's read 
058f d3 10		    OUT (io_10_fdc_command),A 
0591 f1			    POP AF 
0592			    ; If the mode is single density, let's read the 128 bytes 
0592 28 05		    JR Z, reloc_read_the_rest 
0594			reloc_read_first_256_bytes: 
0594 76			    HALT 
0595 ed a2		    INI ; IN from io_13_fdc_data 
0597 20 fb		    JR NZ, reloc_read_first_256_bytes 
0599			reloc_read_the_rest: 
0599			    ; The rest will be 256 bytes on buffer mode and 128 bytes in single density mode 
0599 76			    HALT 
059a ed a2		    INI ; IN from io_13_fdc_data 
059c 20 fb		    JR NZ, reloc_read_the_rest 
059e			    ; We are done 
059e 18 0f		    JR read_write_sector_completed 
05a0			 
05a0			reloc_write_sector: 
05a0 d3 10		    OUT (io_10_fdc_command),A ; A = fdc_command_write_sector 
05a2 f1			    POP AF 
05a3			    ; if the mode is single density, let's write the 128 bytes 
05a3 28 05		    JR Z, reloc_write_the_rest 
05a5			reloc_write_first_256_bytes: 
05a5 76			    HALT 
05a6 ed a3		    OUTI ; OUT to io_13_fdc_data 
05a8 20 fb		    JR NZ,reloc_write_first_256_bytes 
05aa			reloc_write_the_rest: 
05aa			    ; The rest will be 256 bytes on buffer mode and 128 bytes in single density mode 
05aa 76			    HALT 
05ab ed a3		    OUTI ; OUT to io_13_fdc_data 
05ad 20 fb		    JR NZ, reloc_write_the_rest 
05af			 
05af			read_write_sector_completed: 
05af			    ; Restore the byte that was on the NMI handler 
05af 08			    EX AF,AF' ; '  
05b0 32 66 00		    LD (nmi_isr),A 
05b3			    ; Restore the ROM 
05b3 db 1c		    IN A,(io_1c_system_bits) 
05b5 cb ff		    SET system_bit_bank,A 
05b7 d3 1c		    OUT (io_1c_system_bits),A 
05b9 fb			    EI 
05ba			    ; Wait for the disk access result code 
05ba cd c4 04		    CALL wait_for_result 
05bd			    ; Return the result code: 0 or 1 
05bd a2			    AND D ; fdc_status_read_error_bitmask or fdc_status_write_error_bitmask 
05be			    ; If no error return with A = 0 
05be c8			    RET Z 
05bf			    ; If error return with A = 1 
05bf 3e 01		    LD A,0x1 
05c1 c9			    RET 
05c2			block_to_relocate_end: 
05c2			 
05c2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
05c2			; IO PORTS INITIALIZATION 
05c2			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
05c2			 
05c2			init_ports_count: 
05c2 1c			    DB 0x1C 
05c3			init_ports_data: 
05c3			    ; Keyboard, SIO-B. See Z80-SIO Technical Manual 
05c3 07 18		    DB io_07_keyboard_control, 0x18 ; Reset 
05c5 0c 05		    DB io_0c_keyboad_baud_rate, 0x05 ; Set 8816 clock generator to 300 baud 
05c7 07 04		    DB io_07_keyboard_control, 0x04 ; WR4 
05c9 07 44		    DB io_07_keyboard_control, 0x44 ;   = 0x44, CLK/32, 1 Stop bit, no parity 
05cb 07 03		    DB io_07_keyboard_control, 0x03 ; WR3 
05cd 07 c1		    DB io_07_keyboard_control, 0xC1 ;   = 0xc1, 8bits, RX enable 
05cf 07 05		    DB io_07_keyboard_control, 0x05 ; WR5 
05d1 07 e8		    DB io_07_keyboard_control, 0xE8 ;   = 0xe8, 8bits TX, TX enable, DTR 
05d3 07 01		    DB io_07_keyboard_control, 0x01 ; WR1 
05d5 07 00		    DB io_07_keyboard_control, 0x00 ;   = 0x00, disable interrupts 
05d7			 
05d7			    ; Serial port, SIO-A. See Z80-SIO Technical Manual 
05d7 06 18		    DB io_06_serial_control, 0x18 ; Reset 
05d9 00 05		    DB io_00_serial_baud_rate, 0x05 ; Set 8816 clock generator to 300 baud 
05db 06 04		    DB io_06_serial_control, 0x04 ; WR4 
05dd 06 44		    DB io_06_serial_control, 0x44 ;   = 0x44, CLK/32, 1 Stop bit, no parity 
05df 06 03		    DB io_06_serial_control, 0x03 ; WR3 
05e1 06 e1		    DB io_06_serial_control, 0xE1 ;   = 0xe1, 8bits, auto-enable, RX enable 
05e3 06 05		    DB io_06_serial_control, 0x05 ; WR5 
05e5 06 e8		    DB io_06_serial_control, 0xE8 ;   = 0xe8, 8bits TX, TX enable, DTR 
05e7 06 01		    DB io_06_serial_control, 0x01 ; WR1 
05e9 06 00		    DB io_06_serial_control, 0x00 ;   = 0x00, disable interrupts 
05eb			 
05eb			    ; System bits, PIO-2A. See Z80-PIO Technical Manual 
05eb 1d 03		    DB io_1d_system_bits_control, 0x03 ; Enable interrupts with AND 
05ed 1c 81		    DB io_1c_system_bits, 0x81 ;  system_bits = 0x81, drive A, ROM enabled 
05ef 1d cf		    DB io_1d_system_bits_control, 0xCF ; set mode 3-control 
05f1 1d 08		    DB io_1d_system_bits_control, 0x08 ; direction = IOOO_OOOO 
05f3			     
05f3			    ; Parallel port, PIO-1A. See Z80-PIO Technical Manual 
05f3 09 03		    DB io_09_parallel_control, 0x03 ; Enable interrupts with AND 
05f5 09 0f		    DB io_09_parallel_control, 0x0F ; set mode 0-output 
05f7			 
05f7			    ; Parallel port, PIO-1B. See Z80-PIO Technical Manual 
05f7 0b 03		    DB io_0b_parallel_b_control, 0x03 ; Enable interrupts with AND 
05f9 0b 4f		    DB io_0b_parallel_b_control, 0x4F ; set mode 1-input 
05fb			EP_INITDEV: 
05fb 21 c2 05		    LD HL,init_ports_count 
05fe 46			    LD B,(HL) 
05ff			init_ports_loop: 
05ff 23			    INC HL 
0600 4e			    LD C,(HL) 
0601 23			    INC HL 
0602 7e			    LD A,(HL) 
0603			    ; An out for each pair of bytes in init_ports_data 
0603 ed 79		    OUT (C),A 
0605 10 f8		    DJNZ init_ports_loop 
0607 c9			    RET 
0608			 
0608			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0608			; KEYBOARD 
0608			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0608			 
0608			EP_KBDSTAT: 
0608			    ; return 0 or FF in A 
0608 db 07		    IN A, (io_07_keyboard_control) 
060a e6 01		    AND 0x1 
060c c8			    RET Z 
060d 3e ff		    LD A,0xff 
060f c9			    RET 
0610			 
0610			EP_KBDIN: 
0610			    ; return char in A 
0610 cd 08 06		    CALL EP_KBDSTAT 
0613 28 fb		    JR Z, EP_KBDIN 
0615 db 05		    IN A, (io_05_keyboard_data) 
0617 cd 25 06		    CALL translate_keyboard_in_a 
061a c9			    RET 
061b			 
061b			EP_KBDOUT: 
061b			    ; char in C. C=4 for the bell. 
061b db 07		    IN A, (io_07_keyboard_control) 
061d e6 04		    AND 0x4 
061f			     ; Loop until a key is pressed 
061f 28 fa		    JR Z, EP_KBDOUT 
0621 79			    LD A,C 
0622 d3 05		    OUT (io_05_keyboard_data),A 
0624 c9			    RET 
0625			 
0625			translate_keyboard_in_a: 
0625 21 3a 06		    LD HL,translate_keyboard_keys 
0628 01 13 00		    LD BC,translate_keyboard_size 
062b ed b1		    CPIR 
062d			    ; Key not found, return the key not translated 
062d c0			    RET NZ 
062e			    ; Key found, replace with the corresponding char 
062e 11 3a 06		    LD DE,translate_keyboard_keys 
0631 b7			    OR A 
0632 ed 52		    SBC HL,DE 
0634 11 4c 06		    LD DE,translate_keyboard_values-1 
0637 19			    ADD HL,DE 
0638 7e			    LD A,(HL) 
0639 c9			    RET 
063a			translate_keyboard_size: EQU 0x13 
063a			translate_keyboard_keys: 
063a f1 f2 f3 f4	    DB 0xF1, 0xF2, 0xF3, 0xF4 ; Arrow keys 
063e b1 c0 c1 c2	    DB 0xB1, 0xC0, 0xC1, 0xC2 ; Numerical keypad 
0642 d0 d1 d2 e1	    DB 0xD0, 0xD1, 0xD2, 0xE1 
0646 e2 e3 e4 d3	    DB 0xE2, 0xE3, 0xE4, 0xD3 
064a c3 b2		    DB 0xC3, 0xB2 
064c ff			    DB 0xFF 
064d			translate_keyboard_values: 
064d 80 81 82 83	    DB 0x80, 0x81, 0x82, 0x83 ; Arrow keys 
0651 84 85 86 87	    DB 0x84, 0x85, 0x86, 0x87 ; Numerical keypad 
0655 88 89 8a 8b	    DB 0x88, 0x89, 0x8A, 0x8B 
0659 8c 8d 8e 8f	    DB 0x8C, 0x8D, 0x8E, 0x8F 
065d 90 91		    DB 0x90, 0x91 
065f			 
065f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
065f			; SERIAL 
065f			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
065f			 
065f			EP_SIOSTI: 
065f			    ; return 0 or FF in A 
065f db 06		    IN A, (io_06_serial_control) 
0661 e6 01		    AND 0x1 
0663 18 1c		    JR force_0_or_ff 
0665			 
0665			EP_SIOIN: 
0665			    ; return char in A 
0665 cd 5f 06		    CALL EP_SIOSTI 
0668 28 fb		    JR Z, EP_SIOIN 
066a db 04		    IN A, (io_04_serial_data) 
066c c9			    RET 
066d			 
066d			EP_SIOOUT: 
066d			    ; char in C 
066d db 06		    IN A, (io_06_serial_control) 
066f e6 04		    AND 0x4 
0671			    ; Loop until a byte is ready 
0671 28 fa		    JR Z, EP_SIOOUT 
0673 79			    LD A,C 
0674 d3 04		    OUT (io_04_serial_data), A 
0676 c9			    RET 
0677			 
0677			EP_SERSTO: 
0677 db 06		    IN A, (io_06_serial_control) 
0679 e6 04		    AND 0x4 
067b 18 04		    JR force_0_or_ff 
067d			 
067d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
067d			; PARALLEL 
067d			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
067d			 
067d			EP_LISTST: 
067d			    ; return 0 or FF in A 
067d db 1c		    IN A, (io_1c_system_bits) 
067f cb 5f		    BIT system_bit_centronicsReady, A 
0681			force_0_or_ff: 
0681 c8			    RET Z 
0682 3e ff		    LD A,0xff 
0684 c9			    RET 
0685			 
0685			EP_LIST: 
0685			    ; char in C 
0685			    ; Loop until the printer is ready 
0685 cd 7d 06		    CALL EP_LISTST 
0688 28 fb		    JR Z, EP_LIST 
068a			    ; Ouput the byte in C 
068a 79			    LD A,C 
068b d3 08		    OUT (io_08_parallel_data), A 
068d			    ; Pulse the strobe signal 
068d db 1c		    IN A, (io_1c_system_bits) 
068f cb e7		    SET system_bit_centronicsStrobe, A 
0691 d3 1c		    OUT (io_1c_system_bits), A 
0693 cb a7		    RES system_bit_centronicsStrobe, A 
0695 d3 1c		    OUT (io_1c_system_bits), A 
0697 c9			    RET 
0698			 
0698			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0698			; CONSOLE OUTPUT 
0698			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 
0698			 
0698			EP_INITVID: 
0698			    ; Clear stored ESC command argument 
0698 3e 20		    LD A, ' ' 
069a 32 75 fe		    LD (console_esc_equal_first_arg),A 
069d			    ; clear screen and put the cursor at the top left 
069d cd 57 07		    CALL console_clear_screen 
06a0 22 76 fe		    LD (console_cursor_position),HL 
06a3			    ; Disable esc mode 
06a3 af			    XOR A 
06a4 32 74 fe		    LD (console_esc_mode),A 
06a7			    ; ?? 
06a7 3e 17		    LD A,0x17 
06a9 d3 14		    OUT (io_14_scroll_register),A 
06ab			    ; Set ASCII mode 
06ab 3e 7f		    LD A,console_alphabet_ascii_mask 
06ad 32 78 fe		    LD (console_alphabet_mask),A 
06b0 c9			    RET 
06b1			 
06b1			EP_VIDOUT: 
06b1			    ; char in C 
06b1			    ; Are we processing an escape sequence? 
06b1 3a 74 fe		    LD A, (console_esc_mode) 
06b4 b7			    OR A ; Clear carry 
06b5 c2 ce 07		    JP NZ, process_esc_command 
06b8			    ; Is it a BELL? 
06b8 3e 07		    LD A,0x7 ; ^G BELL 
06ba b9			    CP C 
06bb 20 05		    JR NZ, EP_VIDOUT_cont 
06bd			    ; BELL sends a 4 to the keyboard to beep 
06bd 0e 04		    LD C,0x4 
06bf c3 1b 06		    JP EP_KBDOUT 
06c2			EP_VIDOUT_cont: 
06c2 cd b5 07		    CALL remove_blink_and_get_cursor_position 
06c5			    ; Push console_write_end to the stack to execute on any RET 
06c5 11 28 08		    LD DE, console_write_end 
06c8 d5			    PUSH DE 
06c9			    ; Test all special chars 
06c9 79			    LD A,C 
06ca fe 0a		    CP 0xa 
06cc 28 64		    JR Z, console_line_feed 
06ce fe 0d		    CP 0xd 
06d0 ca c3 07		    JP Z, console_carriage_return 
06d3 fe 08		    CP 0x8 
06d5 28 61		    JR Z, console_backspace 
06d7 fe 0c		    CP 0xc 
06d9 28 63		    JR Z, console_right 
06db fe 0b		    CP 0xb 
06dd 28 67		    JR Z, console_up 
06df fe 1b		    CP 0x1b 
06e1 ca c8 07		    JP Z, enable_esc_mode 
06e4 fe 18		    CP 0x18 
06e6 ca 90 07		    JP Z, console_erase_to_end_of_line 
06e9 fe 17		    CP 0x17 
06eb 28 7f		    JR Z,console_erase_to_end_of_screen 
06ed fe 1a		    CP 0x1a 
06ef 28 66		    JR Z,console_clear_screen 
06f1 fe 1e		    CP 0x1e 
06f3 28 73		    JR Z,console_home_cursor 
06f5			    ; For lowercase chars we may apply a conversion to greek 
06f5			    ; letters.  
06f5 fe 60		    CP 'a'-1 
06f7 38 04		    JR C,skip_greek_conversion 
06f9			    ; Apply the alphabet mask 
06f9 3a 78 fe		    LD A,(console_alphabet_mask) 
06fc a1			    AND C 
06fd			skip_greek_conversion: 
06fd			    ; Write the char at the cursor position 
06fd 77			    LD (HL),A 
06fe			    ; Advance the cursor 
06fe 23			    INC HL 
06ff 7d			    LD A,L 
0700			    ; Return if we are not at the and of the line 
0700 e6 7f		    AND 0x7f 
0702 fe 50		    CP console_columns 
0704 d8			    RET C 
0705			    ; We are at the end of the line CR + LF 
0705 cd c3 07		    CALL console_carriage_return 
0708 18 28		    JR console_line_feed 
070a			 
070a			console_line_feed_cont: 
070a			    ; Let's check if the cursor is past the end of the screen 
070a 11 ff 3b		    LD DE, address_vram_end 
070d 7a			    LD A,D 
070e bc			    CP H 
070f 38 04		    JR C,console_line_feed_scroll 
0711 c0			    RET NZ 
0712 7b			    LD A,E 
0713 bd			    CP L 
0714 d0			    RET NC 
0715			 
0715			console_line_feed_scroll: 
0715			    ; We are at the end of the screen, scroll the screen 
0715			    ; Move all lines except the first up 
0715 06 17		    LD B, console_lines - 1 
0717			    ; Copy 80 chars from each line to the prev one 
0717			    ; Starting by the second line 
0717 21 80 30		    LD HL, address_vram + console_line_length 
071a 11 00 30		    LD DE, address_vram 
071d			console_line_feed_scroll_loop: 
071d c5			    PUSH BC 
071e			    ; Copy 80 chars 
071e 01 50 00		    LD BC, console_columns 
0721 ed b0		    LDIR 
0723			    ; Skip the 128 - 80 chars not used 
0723 01 30 00		    LD BC,console_line_length - console_columns 
0726 09			    ADD HL,BC 
0727 eb			    EX DE,HL 
0728 09			    ADD HL,BC 
0729 eb			    EX DE,HL 
072a c1			    POP BC 
072b			    ; Repeat for each line 
072b 10 f0		    DJNZ console_line_feed_scroll_loop 
072d			    ; Place the cursor at the bottom left 
072d 21 80 3b		    LD HL, address_vram_start_of_last_line 
0730 18 5e		    JR console_erase_to_end_of_line 
0732			 
0732			console_line_feed: 
0732			    ; Advance the cursor to the next line 
0732 11 80 00		    LD DE, console_line_length 
0735 19			    ADD HL,DE 
0736			    ; Scroll up if needed 
0736 18 d2		    JR console_line_feed_cont 
0738			 
0738			console_backspace: 
0738 7d			    LD A,L 
0739 e6 7f		    AND console_line_mask 
073b			    ; Ignore if we are already at the beginning of the line 
073b c8			    RET Z 
073c			    ; Move the cursor to the previous char 
073c 2b			    DEC HL 
073d c9			    RET 
073e			 
073e			console_right: 
073e 7d			    LD A,L 
073f e6 7f		    AND console_line_mask 
0741			    ; Ignore if we are already at the end of the line 
0741 fe 4f		    CP console_columns-1 
0743 d0			    RET NC 
0744			    ; Move the cursor to the next char 
0744 23			    INC HL 
0745 c9			    RET 
0746			 
0746			console_up: 
0746 e5			    PUSH HL 
0747			    ; Move one line up 
0747 11 80 ff		    LD DE, -console_line_length 
074a 19			    ADD HL,DE 
074b e5			    PUSH HL 
074c			    ; Are we moved too far up? 
074c b7			    OR A ; Clear carry 
074d 11 00 30		    LD DE,address_vram 
0750 ed 52		    SBC HL,DE 
0752 e1			    POP HL ; Updated position 
0753 d1			    POP DE ; Original position 
0754			    ; No, we re ok 
0754 d0			    RET NC 
0755			    ; Yes, restore the original position 
0755 eb			    EX DE,HL 
0756 c9			    RET 
0757			 
0757			console_clear_screen: 
0757			    ; Put a space at the beginning of the screen 
0757			    ; and for the rest of the screen, copy the previous char (a space) 
0757 21 00 30		    LD HL, address_vram 
075a 11 01 30		    LD DE, address_vram + 1 
075d 01 ff 0b		    LD BC, console_lines * console_line_length - 1 
0760 36 20		    LD (HL), ' ' 
0762 ed b0		    LDIR 
0764			    ; Set the cursor to the beginning of the screen 
0764 21 00 30		    LD HL,address_vram 
0767 c9			    RET 
0768			 
0768			console_home_cursor: 
0768			    ; Set the cursor to the beginning of the screen 
0768 21 00 30		    LD HL,address_vram 
076b c9			    RET 
076c			 
076c			console_erase_to_end_of_screen: 
076c e5			    PUSH HL 
076d cd 90 07		    CALL console_erase_to_end_of_line 
0770 11 80 00		    LD DE, console_line_length 
0773			    ; Move cursor to the beggining of the current line 
0773 7d			    LD A,L 
0774 e6 80		    AND console_line_length 
0776 6f			    LD L,A 
0777			    ; Move cursor the the next line 
0777 19			    ADD HL,DE 
0778			    ; Did we move past the end the the screen? 
0778 3e 3c		    LD A,0x3c ; MSB byte of the position past the end of the screen 
077a bc			    CP H 
077b			    ; If yes, restore cursor and return 
077b 28 11		    JR Z,console_restore_cursor_position 
077d			    ; Write spaces until the end of the screen 
077d			    ; Set in CB the count of spaces to write 
077d 5d			    LD E,L 
077e 54			    LD D,H 
077f b7			    OR A ; Clear carry 
0780 21 ff 3b		    LD HL, address_vram_end 
0783 ed 52		    SBC HL,DE 
0785 4d			    LD C,L 
0786 44			    LD B,H 
0787			    ; Set DE as the next char 
0787 62			    LD H,D 
0788 6b			    LD L,E 
0789 13			    INC DE 
078a			    ; Fill with spaces copying the previous char until the end of the screen 
078a 36 20		    LD (HL), ' ' 
078c ed b0		    LDIR 
078e			console_restore_cursor_position: 
078e e1			    POP HL 
078f c9			    RET 
0790			 
0790			console_erase_to_end_of_line: 
0790 7d			    LD A,L 
0791 e6 7f		    AND console_line_mask 
0793			    ; Are we at the last position of the line? 
0793 fe 4f		    CP console_columns-1 
0795			    ; No 
0795 38 03		    JR C,console_erase_to_end_of_line_cont 
0797			    ; Yes, write a space and return 
0797 36 20		    LD (HL), ' ' 
0799 c9			    RET 
079a			console_erase_to_end_of_line_cont: 
079a e5			    PUSH HL 
079b e5			    PUSH HL 
079c			    ; Move to the start of the line 
079c 7d			    LD A,L 
079d e6 80		    AND console_line_length 
079f 6f			    LD L,A 
07a0			    ; Move to the end of the line 
07a0 11 4f 00		    LD DE, console_columns - 1 
07a3 19			    ADD HL,DE 
07a4 d1			    POP DE ; Original position 
07a5 d5			    PUSH DE 
07a6			    ; Set CB to the count of spaces to write from cursor to the end of the line 
07a6 b7			    OR A ; Clear carry 
07a7 ed 52		    SBC HL,DE 
07a9 4d			    LD C,L 
07aa 44			    LD B,H 
07ab			    ; Set DE as the next char 
07ab e1			    POP HL 
07ac 5d			    LD E,L 
07ad 54			    LD D,H 
07ae 13			    INC DE 
07af			    ; Fill with spaces copying the previous char until the end of the line 
07af 36 20		    LD (HL), ' ' 
07b1 ed b0		    LDIR 
07b3 e1			    POP HL 
07b4 c9			    RET 
07b5			 
07b5			remove_blink_and_get_cursor_position: 
07b5			    ; Get the cursor position 
07b5 2a 76 fe		    LD HL,(console_cursor_position) 
07b8 7e			    LD A,(HL) 
07b9			    ; Is the char at the cursor a blinking '_' 
07b9 fe df		    CP '_' + 0x80 
07bb 3e 20		    LD A, ' ' 
07bd			    ; No, continue 
07bd 20 01		    JR NZ,remove_blink_and_get_cursor_position_cont 
07bf			    ; Yes, put back a space 
07bf 77			    LD (HL),A 
07c0			remove_blink_and_get_cursor_position_cont: 
07c0			    ; Remove the blink bit 
07c0 cb be		    RES 0x7,(HL) 
07c2 c9			    RET 
07c3			 
07c3			console_carriage_return: 
07c3			    ; Set column to 0 by clearing the 7 LS bits on the cursor position 
07c3 7d			    LD A,L 
07c4 e6 80		    AND console_line_length 
07c6 6f			    LD L,A 
07c7 c9			    RET 
07c8			 
07c8			enable_esc_mode: 
07c8			    ; Enable esc mode, next char will be an ESC command 
07c8 3e 01		    LD A,console_esc_mode_enabled 
07ca 32 74 fe		    LD (console_esc_mode),A 
07cd c9			    RET 
07ce			 
07ce			process_esc_command: 
07ce			    ; A has the esc mode 
07ce			    ; C has the char to process 
07ce			    ; Push the location of a RET on the stack. A RET will be another RET? 
07ce 21 35 08		    LD HL, ret_opcode_address 
07d1 e5			    PUSH HL 
07d2			    ; Reset ESC mode 
07d2 21 74 fe		    LD HL,console_esc_mode 
07d5 36 00		    LD (HL), console_esc_mode_clear 
07d7			    ; Are we in a n ESC mode past ebaled? 
07d7 fe 01		    CP console_esc_mode_enabled 
07d9			    ; Yes, process esc argument 
07d9 20 19		    JR NZ,process_esc_arg_1 
07db			    ; No, process the command 
07db			    ; Load the char in A with the upper bit cleared (no blink) 
07db 79			    LD A,C 
07dc cb bf		    RES 0x7,A 
07de fe 47		    CP 'G' 
07e0 28 54		    JR Z, esc_set_greek_mode 
07e2 fe 41		    CP 'A' 
07e4 28 56		    JR Z,esc_set_ascii_mode 
07e6 fe 52		    CP 'R' 
07e8 28 58		    JR Z,esc_line_delete 
07ea fe 45		    CP 'E' 
07ec 28 66		    JR Z,esc_line_insert 
07ee fe 3d		    CP '=' 
07f0			    ;  Not a known ESC command, we ignore the char and return 
07f0 c0			    RET NZ 
07f1			    ; Command is '=', we set that mode 
07f1 36 02		    LD (HL),console_esc_mode_arg_1 
07f3 c9			    RET 
07f4			 
07f4			process_esc_arg_1: 
07f4			    ; Are we in an ESC mode past arg_1 
07f4 fe 02		    CP console_esc_mode_arg_1 
07f6			    ; Yes 
07f6 20 07		    JR NZ,process_esc_arg_2 
07f8			    ; No, store the first argmument and return 
07f8 79			    LD A,C 
07f9 32 75 fe		    LD (console_esc_equal_first_arg),A 
07fc 36 03		    LD (HL),console_esc_mode_arg_2 
07fe c9			    RET 
07ff			 
07ff			process_esc_arg_2: 
07ff			    ; Are we in an ESC mode past arg_2 
07ff fe 03		    CP console_esc_mode_arg_2 
0801			    ; Yes, just return 
0801 c0			    RET NZ 
0802 cd b5 07		    CALL remove_blink_and_get_cursor_position 
0805 e1			    POP HL 
0806			    ; Put the cursor at the top right corner 
0806 21 00 30		    LD HL,address_vram 
0809			    ; Second arg is column + 0x20 
0809 79			    LD A,C 
080a d6 20		    SUB 0x20 
080c			    ; Get the modulo 80 
080c			esc_arg_2_mod_80_loop: 
080c d6 50		    SUB console_columns 
080e 30 fc		    JR NC,esc_arg_2_mod_80_loop 
0810 c6 50		    ADD A,console_columns 
0812			    ; Advance to te arg_2 column 
0812 6f			    LD L,A 
0813			    ; First arg is row + 0x20 
0813 3a 75 fe		    LD A,(console_esc_equal_first_arg) 
0816 d6 20		    SUB 0x20 
0818			    ; Get the modulo 24 
0818			esc_arg_2_mod_24_loop: 
0818 d6 18		    SUB console_lines 
081a 30 fc		    JR NC,esc_arg_2_mod_24_loop 
081c c6 18		    ADD A,console_lines 
081e			    ; Advance to the arg_1 row by advancing a line per row 
081e 11 80 00		    LD DE,console_line_length 
0821			move_down_loop: 
0821 ca 28 08		    JP Z,console_write_end 
0824 19			    ADD HL,DE 
0825 3d			    DEC A 
0826 18 f9		    JR move_down_loop 
0828			 
0828			console_write_end: 
0828			    ; Finish the console_write and enable blink at the cursor position 
0828			    ; HL has the cursor position 
0828			    ; Get the char under the cursos 
0828 7e			    LD A,(HL) 
0829			    ; If it is a space, we write a blinking '_' 
0829 fe 20		    CP 0x20 
082b 20 02		    JR NZ, console_write_end_cont 
082d 3e df		    LD A,'_' + 0x80 
082f			console_write_end_cont: 
082f			    ; Set the upper bit of the char to blink 
082f cb ff		    SET 0x7,A 
0831 77			    LD (HL),A 
0832			    ; Store the cursor position 
0832 22 76 fe		    LD (console_cursor_position),HL 
0835			ret_opcode_address: 
0835 c9			    RET 
0836			 
0836			esc_set_greek_mode: 
0836			    ; Store the mask for chars to write 
0836			    ; For greek chars, we map to 0 to 0x1f 
0836 3e 1f		    LD A,console_alphabet_greek_mask 
0838 32 78 fe		    LD (console_alphabet_mask),A 
083b c9			    RET 
083c			 
083c			esc_set_ascii_mode: 
083c			    ; Store the mask for chars to write 
083c			    ; For ASCII, we just remove the blink bit 
083c 3e 7f		    LD A,console_alphabet_ascii_mask 
083e 32 78 fe		    LD (console_alphabet_mask),A 
0841 c9			    RET 
0842			 
0842			esc_line_delete: 
0842 e1			    POP HL 
0843			    ; Prepare HL, DE, BC and the Z flag 
0843 cd 6b 08		    CALL esc_line_insert_or_delete_prepare 
0846 d5			    PUSH DE 
0847			    ; Skip copy if there is nothing to copy 
0847 28 02		    JR Z,esc_line_delete_end 
0849 ed b0		    LDIR 
084b			esc_line_delete_end: 
084b			    ; Delete the last line, it is always empty after a line delete 
084b 21 80 3b		    LD HL, address_vram_start_of_last_line 
084e cd 90 07		    CALL console_erase_to_end_of_line 
0851			    ; Set the cursor to it's original position 
0851 e1			    POP HL 
0852			    ; Done 
0852 18 d4		    JR console_write_end 
0854			 
0854			esc_line_insert: 
0854 e1			    POP HL 
0855			    ; Prepare HL, DE, BC and the Z flag 
0855 cd 6b 08		    CALL esc_line_insert_or_delete_prepare 
0858 d5			    PUSH DE 
0859			    ; Skip copy if there is nothing to copy 
0859 28 08		    JR Z,esc_line_insert_end 
085b			    ; Copy lines down up to the cursor line 
085b 11 ff 3b		    LD DE, address_vram_end 
085e 21 7f 3b		    LD HL, address_vram_start_of_last_line - 1 
0861 ed b8		    LDDR 
0863			esc_line_insert_end: 
0863			    ; Delete the line as we insert a blank line 
0863 e1			    POP HL 
0864 e5			    PUSH HL 
0865 cd 90 07		    CALL console_erase_to_end_of_line 
0868			    ; Set the cursor to the start of the line 
0868 e1			    POP HL 
0869			    ; Done 
0869 18 bd		    JR console_write_end 
086b			 
086b			esc_line_insert_or_delete_prepare: 
086b cd b5 07		    CALL remove_blink_and_get_cursor_position 
086e cd c3 07		    CALL console_carriage_return 
0871 e5			    PUSH HL 
0872 eb			    EX DE,HL 
0873			    ; Position of the bottom left 
0873 21 80 3b		    LD HL, address_vram_start_of_last_line 
0876			    ; Set BC to the count of bytes until the end of the screen minus one line 
0876 b7			    OR A ; Clear carry 
0877 ed 52		    SBC HL,DE 
0879 44			    LD B,H 
087a 4d			    LD C,L 
087b			    ; Set HL to the start of the next line 
087b e1			    POP HL 
087c e5			    PUSH HL 
087d 11 80 00		    LD DE,console_line_length 
0880 19			    ADD HL,DE 
0881			    ; Set DE to the start of the current line 
0881 d1			    POP DE 
0882			    ; Set Z flag if BC is zero. To be used later. 
0882 78			    LD A,B 
0883 b1			    OR C 
0884			    ; Back to insert or delete line 
0884 c9			    RET 
0885			 
0885			console_write_string: 
0885			    ; Get return address from the stack 
0885 e3			    EX (SP),HL 
0886			    ; Read the char pointed there 
0886 7e			    LD A,(HL) 
0887			    ; Increment by one the return address in the stack 
0887 23			    INC HL 
0888 e3			    EX (SP),HL 
0889			    ; If the char is a zero, we are done with the string and can 
0889			    ; return to the caller on the address past the string 
0889 b7			    OR A 
088a c8			    RET Z 
088b			    ; Write the char and continue with the string 
088b 4f			    LD C,A 
088c cd b1 06		    CALL EP_VIDOUT 
088f 18 f4		    JR console_write_string 
0891			 
0891			filler: 
0891 0xff...		    DS 0x76f, 0xff 
# End of file 81-232.s
1000
